# 전략패턴

## 오리 시뮬레이션 게임, SimUduck
오리 시뮬레이션 게임을 만든다고 가정하자..
이 게임에는 오리라는 객체가 헤엄도 치고 꽥꽥 소리도 낸다고 한다. 표준 객체지향 기법을 사용하여 Duck이라는 슈퍼클래스를 만든 다음, 그 클래스를 확작해서
서로 다른 종류의 오리를 만든다고 한다.
<br>
## 이슈1
> 특정 오리 즉 몇몇 서브 클래스만 날아야 하는 사실을 잊고 있었다. Duck이라는 슈퍼클래스에 fly() 메소드를 추가하면서 일부 서브클래스에 적합하지 않은
> 행동이 추가된 것이다.

이러한 문제를 해결하기 위해서는
- quack()메소드에서 한것처럼 fly()메소드도 오버라이드

## 인터페이스 설계하기
> 상속은 올바른 해결책이 아니다.

상속을 계속 활용하면 클래스의 규격이 바뀔 때마다 프로그램에 추가했던 Duck의 sub클래스 fly()와 quack() 메소드를 일일이 살펴보고 상황에 따라 오버라이드 해야한다.

소프트웨어 개발에서 절대로 바뀌지 않는 진리는 무엇일까요?

`"변화"`

디자인을 잘한 앱이라도 시간이 지남에 따라 변화하고 성장해야 한다.

## 디자인 원칙1(애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다!)
`달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 '캡슐화' 한다.` 그러면 코드를 변경하는 과정에서 반복과 같은 의도치 않은 상황을 줄이며 SW의 유연성을 향상 시킬 수 있다.


## 바뀌는 부분과 그렇지 않은 부분 분리하기

- fly(), quack()은 Duck 클래스에 있는 오리 종류에 따라 달라지는 부분입니다.

결과적으로 설계를 한다면 Duck이 클라이언트, 각각의 행동을 FlyBehavior과 QuackBehavior로 나누게 됩니다.
나눠진 행동들을 인터페이스로 설계하고 그 뒤에 인터페이스를 구현하는 구현체로 각각의 행동의 특성에 따라 분리합니다.

## 디자인 원칙2(구현보다는 인텊페이스에 맞춰서 프로그래밍 한다.)
> 각 행동은 인터페이스(예: FlyBehavior, QuackBehavior)로 표현하고 이런 인터페이스를 사용해서 행동을 구현하겠습니다. 
나는 행동과 꽥꽥거리는 행동은 이제 Duck 클래스에서 구현하 지 않습니다.

이렇게 설계한다면 subclass에 국한되지 않게 됩니다.

```java
package main.ch1.behavior;

public interface FlyBehavior {
    public void fly();
}
```

```java
package main.ch1.behavior;

public interface QuackBehavior {
    public void quack();
}
```

## 디자인원칙3(상속보다는 구성을 활용한다)
아까 위에서 설계한것과 같이 `두가지의 행동을 분리했습니다.` 이런식으로 두 클래스를 합치는 것을 `구성`한다 라고 부릅니다.

구성을 활용한다면 유연성을 크게 향상시킬 수 있고, 객체에서 올바른 행동 인터페이스만 구현하면 교체할 때도 편리합니다.