# 전략패턴

## 오리 시뮬레이션 게임, SimUduck
오리 시뮬레이션 게임을 만든다고 가정하자..
이 게임에는 오리라는 객체가 헤엄도 치고 꽥꽥 소리도 낸다고 한다. 표준 객체지향 기법을 사용하여 Duck이라는 슈퍼클래스를 만든 다음, 그 클래스를 확작해서
서로 다른 종류의 오리를 만든다고 한다.
<br>
## 이슈1
> 특정 오리 즉 몇몇 서브 클래스만 날아야 하는 사실을 잊고 있었다. Duck이라는 슈퍼클래스에 fly() 메소드를 추가하면서 일부 서브클래스에 적합하지 않은
> 행동이 추가된 것이다.

이러한 문제를 해결하기 위해서는
- quack()메소드에서 한것처럼 fly()메소드도 오버라이드

## 인터페이스 설계하기
> 상속은 올바른 해결책이 아니다.

상속을 계속 활용하면 클래스의 규격이 바뀔 때마다 프로그램에 추가했던 Duck의 sub클래스 fly()와 quack() 메소드를 일일이 살펴보고 상황에 따라 오버라이드 해야한다.

소프트웨어 개발에서 절대로 바뀌지 않는 진리는 무엇일까요?

`"변화"`

디자인을 잘한 앱이라도 시간이 지남에 따라 변화하고 성장해야 한다.

## 디자인 원칙1(애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다!)
`달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 '캡슐화' 한다.` 그러면 코드를 변경하는 과정에서 반복과 같은 의도치 않은 상황을 줄이며 SW의 유연성을 향상 시킬 수 있다.


## 바뀌는 부분과 그렇지 않은 부분 분리하기

- fly(), quack()은 Duck 클래스에 있는 오리 종류에 따라 달라지는 부분입니다.