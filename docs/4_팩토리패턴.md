# 팩토리패턴

예를 들어 다음과 같은 코드를 사용한다면 코드를 관리와 갱신이 어려워집니다.
```java
Duck duck = new MallardDuck();

Duck duck;
if (picnic){
    duck = new MallardDuck();
}
else if(hunting){
    duck = new DecoyDuck();
}
else if(inBathTub){
    duck = new RubberDuck();    
}
```

#### new에 어떤 문제가 있는 것일까?
> new에는 문제가 없지만 변화하는 무언가에 new를 사용하는 것을 조심해야 한다.

인터페이스에 맞추어 코딩을 하게되면 특정 인터페이스만 구현하여 여러변화에 대응할 수 있다. 이는 다형성 덕분이다. 반대로 구상 클래스를 많이 사용하면
새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하므로 수많은 문제가 생길 수 있다. 이는 변경에 닫혀 있는 코드가 될 수 있는 것으로 유도한다. 새로운 
구상형식을 써서 확장을 할 때는 다시 확장에 열려있는 코드로 만들어야한다.

`첫 장에서 배웠던 바뀌는 부분과 바뀌지 않는 부분을 분리한다.`

## 객체 - 팩토리
> 객체 생성을 처리하는 클래스를 팩토리라고 부른다.

간단한 객체 생성을 따로 객체에 빼둠으로써 구현을 변경할 때 팩토리 클래스 하나만 수정하면 된다. 그리고 클라이언트 코드상에서 구상클래스의 인스턴스를 
만드는 코드도 제거할 수 있다.

간단한 팩토리는 정적 메소드로 정의하는 기법으로도 많이 사용된다. 이렇게 함으로써 객체 생성 메소드를 실행하기 위해 객체의 인스턴스를 만들지 않아도 된다.
하지만 서브클래스를 만들기 때문에 객체 생성 메소드의 행동은 변경할 수 없어진다.


> 무슨말? 
디자인 패턴을 얘기할 때, "인터페이스을 구현한다"라는 표현이 나온다고 해서 항상
"클래스를 선언하는 부분에 implements 키워드들 써서 어떤 자바 인터페이스를 구현하는 클래스을 만든다"라고 생각하면 안 됩니다. 일반적으로 어떤 상위 형식(클래스와 인터페이스)에 있는
구상 클래스는 '상위 형식의 인터페이스를 구현하는' 클래스라고 생각하면 됩니다.

## 의존성 뒤집기 원칙

구상 클래스 의존성을 줄이면 좋다. 

> 추상화된 것에 의존하게 만들고 구상 클래스에 이존하지 않게 만든다.

`구현보다는 인터페이스에 맞춰서 프로그래밍한다` 라는 원칙이 똑같다는 생각이 들 수도 있다. 물론 비슷하긴 하지만 의존성 뒤집기 워친에서는 추상화를 더 많이 강조한다. 이 원칙에는
고수준 구성 요소가 저수준 구성 요소에 의존하면 안되며, 항상 추상화에 의존하게 만들어야 한다는 뜻이 담겨있다.