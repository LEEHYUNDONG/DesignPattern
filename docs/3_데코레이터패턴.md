# 데코레이터 패턴

## Starbuzz
> 커피 주문을 한다고 가정해보자, 수많은 커피 커스텀 주문이 들어온다. 젠장.. 이걸 어떻게 클래스로 다 만들어야 할까?
> 슈퍼 클래스 상속을 사용하여 첨가물을 관리할 수는 없는것인가?

- Beverage 클래스
  - mocha
  - whip
  - soy..

인스턴스 변수를 추가한 뒤에 서브클래스를 추가한다. 메뉴마다 서브클래스를 만들어야 한다.

## OCP(Open-Closed Principle)
> 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

`요구사항이나 조건`이 달라지면 클래스를 언제든지 확장, 하지만 코드를 변경하면 안된다. 말이 되게 장난같지만 새로운 행동을 추가하는 것은 가능하되 기존에 
만들었던 행동을 변경하면 안된다는 의미이다.

### OCP를 잘지키는 방법

- OCP를 준수하는 객체지향 디자인은 시간을 갈아넣어야 함
- OCP를 지키다 보면 새로운 단계의 추상화가 필요
- 가장 바뀔 가능성이 높은 부분을 중점적으로 OCP를 적용하기
- 코드에서 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 한다.

## 데코레이터 패턴(FR)
starbuzz 패키지에 있는 것처럼 설계를 하는 것은 좋은 방법이 아니다. 클래스가 엄청 많아지거나 서브클래스에 적합하지 않은 행동, 기능들을 추가해야 하기 때문..

그럼 장식처럼 커피라는 객체위에 꾸며보면 어떨까??

꾸미는 순서
1. DarkRoast 객체를 가져온다.
2. Mocha 객체로 장식한다.
3. Whip 객체로 장식한다.
4. cost 메소드를 호출한다. 이때 첨가물 가격을 계산하는 일은 객체에 위임

`데코레이터 패턴은 결국 여러가지 기능을 구현시` 에 각각 추가기능이 많을 시에 각각을 전부 클래스로 만드는 것이 아닌 데코레이터를 통해 추가 기능 조합을 설계하는 것임.

## 데코레이터 패턴이 적용된 예 :자바 I/O

java.io 패키지는 정말 많은 클래스가 존재한다. IO API를 이해하는데 데코레이터 패턴은 도움이 된다. 

InputStream
- FileInputStream
- StringBufferInputStream
- ByteArrayInputStream
- FilterInputStream
  - PushbackInputStream
  - BufferedInputStream
  - DataInputStream
  - InflatorInputStream
    - ZipInputStream


