# 커맨드 패턴

- 커맨드 패턴을 사용하면 어떤 작업을 요청하는 쪽과 그 작업을 처리하는 쪽을 분리할 수 있다.
- 별도의 커맨드 객체를 추가하여 특정 객체에 관한 특정 작업 요청을 캡슐화 해주면 된다.

#### 음식 주문 과정
1. 고객이 종업원에게 주문
2. 종업원은 주문을 받아서 카운터에 전달하고 '주문이 잘 들어왔다고 전달'
3. 주방장이 주문대로 음식 준비

### 객체마을 식당 등장인물의 역할

__주문서는 주문 내용을 캡슐화한다.__

주문서는 주문 내용을 요구하는 객체라고 볼 수 있다. 다른 객체처럼 이곳저곳에 전달될 수 있다. 종업원이 주문서 객체를 계산대나 다른 종업원에게 전달해 주는 식으로 동작하는데 이 객체의 인터페이스에는 식사 준부에 필요한 행동을
캡슐화한 orderUp() 메소드가 들어있다. 

그리고 그 식사를 주문해야 하는 객체(요리사)의 레퍼런스도 들어있다. 해당 내용은 캡슐화되어 있어 종업원은 어떤 메뉴가 주문되었고 누가 식사 준비를 할 것인지 몰라도 된다.

__종업원은 주문서를 받고 orderUp() 메소드를 호출한다.__

종업원은 주문을 받고 카운터로 가서 orderUp() 메소드를 호출해서 식사 준비를 요청한다. 이미 언급한 것 처럼 객체 마을 식당의 종업원은 주문서에 무슨 내용이 있는지, 누가 식사를 준비하는지는 일절 몰라도 된다. 
종업원의 takeOrder() 메소드에는 여러 고객의 주문서를 매개변수로 전달한다. 

__요리사는 식사를 준비하는 데 필요한 정보를 갖고 있다.__

실제로 식사를 준비하는 방법은 요리사만 알고 있다. 종업원이 orderUp() 메소드를 호출하면 요리사가 그 주문을 받아서 음식을 만들 때 필요한 메소드를 전부 처리한다.

### 커맨드 패턴

- 커맨드 - execute()
  - 하나만 존재한다.
  - 이 메소드는 행동을 캡슐화하여 리시버에 있는 특정 행동을 처리한다.
- 리시버 - action()
  - 커맨드 개체에는 행도과 리시버의 정보가 같이 들어있다.
- 클라이언트 - createCommandObject()
  - 클라이언트 커맨드 객체를 생성해야 함
  - 커맨드 객체는 리시버에 전달할 일련의 행동으로 구성
- 인보커 - setCommand()
  - 클라이언트는 인보커 객체의 메소드를 호출하여 커맨드 객체를 넘겨 받는다
  - 나중에 커맨드 객체를 사용하기 전까지 인보커 객체에 보관

`인보커 로딩`
1. 클라이언트에서 커맨드 객체 생성
2. setCommand()를 호출해서 인보커에 커맨드 객체를 저장
3. 나중에 클라이언트에서 인보커에게 그 명령을 실행하라고 요청


### 커맨드 패턴의 정의

> 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있다.

커맨드 객체는 일련의 행동을 특정 리시버와 연결함으로써 요청을 캡슐화한 것이다. 
이렇게 하려면 행동과 리시버를 한 객체에 넣고 execute()라는 메소드 하나만 외부에 공개하는 방법을 써야 한다. 이 메소드 호출에 따라 리시버에서 일련의 작업을 처리한다.